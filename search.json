[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial 1 - SOPRA",
    "section": "",
    "text": "The goal of SOPRA and particurlaly Milestone 1 is to get familiar with the basics of Full-Stack web development with the chosen frameworks.\nThis guide offers step-by-step tutorials to set-up your local machine for development and deploy it. Conceptual explanations and recommandations are also included.\n\n\n\n\n\n\nNoteWhat’s a Web Application? - Main concepts\n\n\n\n\n\nWeb Application components\nWeb applications are usually built with 3 fundamentals components:\n\nClient: This is what the users see when visiting a web application. It’s responsible to fetch the data and display it to the user in an interactive way. The client can interact with the data trough the backend and a defined API between them (in our and most cases REST)\nBackend (Server): The backend has direct access to the database (can read and write) and offers specific access points (endpoints) to clients. It’s responsible to manage the complexity of retrieving the needed data that clients request and check access permission.\nDatabase: The database store the actual data. There can be many types of databases and languages to interact with it. In this course, a semi-persistent database (only lives in memory, RAM) based on Postgress and accessible trough SQL is set-up.\n\n\n\n\n\n\n\nNoteDiagram\n\n\n\n\n\n\n\n\n\nREST\nREST stands for REpresentational State Transfer and offers CRUD (Create, Read, Update, Delete) operations hitting a specific endpoint.\nEndpoints\nEndpoints are specific URI to describe a specifc resource to retrive: /users/{id}.\nUsed in combination with REST:\nGET /users/{id}\nheader: Authorization token (a key used by the backend to grant acces to the resource)\n\n\n\n\n\n\nNoteDatabase\n\n\n\nThe setup of the server repository in SOPRA already contains and spins up the in-memory database. This means that there is no external database to handle.\n\n\n\nDeployment\nThe 2 repositories templates available for sopra are:\n\nsopra-fs26-template-client\nsopra-fs26-template-server\n\nresponsible for the client and server.\nThese repositories are hosted on Github. As a convention, the main branch represents the latest working instance (what should be deployed and accessible by the users). The 2 repositories are respectively deployed on:\n\nclient on Vercel\nserver (together with the in-memory database) on Google Cloud\n\nThis happens automatically when someone pushes code changes on the main branch: this is managed with Github Workflow to support continuous development (there is no need to manually deploy applications).\n\nDevelopment\nWe usually refer to 2 main environments:\n\nproduction: the one we just discussed and acutally run the application accessible to the users\ndevelopment: where developers work on their local machine, change and share code while implementing new features and fixing bugs.\n\nDevelopers clone the repositories hosted on Github on their local machine, work on the code and push the code (they share the changes to Github – with the other team members). If it’s the case, the automatic CI/CD pipeline defined by Github workflows take care of it and redeploys the application.\nTo run and test the application locally, you need:\n\nlocal application running with the client\nlocal application running wiht the backend (server)\n\n\nDevelopment flow\n\nclone application locally\ninstall needed dependencies to run it locally\nimplement a new feature / fix a bug\ntest locally that everything works correctly\npush the new code the remote (Github) usually on a feature branch\nonce the code is tested and ready to be integrated into production, the feature branch gets merged into the main branch, triggering the deployment"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Tutorial 1 - SOPRA",
    "section": "",
    "text": "The goal of SOPRA and particurlaly Milestone 1 is to get familiar with the basics of Full-Stack web development with the chosen frameworks.\nThis guide offers step-by-step tutorials to set-up your local machine for development and deploy it. Conceptual explanations and recommandations are also included.\n\n\n\n\n\n\nNoteWhat’s a Web Application? - Main concepts\n\n\n\n\n\nWeb Application components\nWeb applications are usually built with 3 fundamentals components:\n\nClient: This is what the users see when visiting a web application. It’s responsible to fetch the data and display it to the user in an interactive way. The client can interact with the data trough the backend and a defined API between them (in our and most cases REST)\nBackend (Server): The backend has direct access to the database (can read and write) and offers specific access points (endpoints) to clients. It’s responsible to manage the complexity of retrieving the needed data that clients request and check access permission.\nDatabase: The database store the actual data. There can be many types of databases and languages to interact with it. In this course, a semi-persistent database (only lives in memory, RAM) based on Postgress and accessible trough SQL is set-up.\n\n\n\n\n\n\n\nNoteDiagram\n\n\n\n\n\n\n\n\n\nREST\nREST stands for REpresentational State Transfer and offers CRUD (Create, Read, Update, Delete) operations hitting a specific endpoint.\nEndpoints\nEndpoints are specific URI to describe a specifc resource to retrive: /users/{id}.\nUsed in combination with REST:\nGET /users/{id}\nheader: Authorization token (a key used by the backend to grant acces to the resource)\n\n\n\n\n\n\nNoteDatabase\n\n\n\nThe setup of the server repository in SOPRA already contains and spins up the in-memory database. This means that there is no external database to handle.\n\n\n\nDeployment\nThe 2 repositories templates available for sopra are:\n\nsopra-fs26-template-client\nsopra-fs26-template-server\n\nresponsible for the client and server.\nThese repositories are hosted on Github. As a convention, the main branch represents the latest working instance (what should be deployed and accessible by the users). The 2 repositories are respectively deployed on:\n\nclient on Vercel\nserver (together with the in-memory database) on Google Cloud\n\nThis happens automatically when someone pushes code changes on the main branch: this is managed with Github Workflow to support continuous development (there is no need to manually deploy applications).\n\nDevelopment\nWe usually refer to 2 main environments:\n\nproduction: the one we just discussed and acutally run the application accessible to the users\ndevelopment: where developers work on their local machine, change and share code while implementing new features and fixing bugs.\n\nDevelopers clone the repositories hosted on Github on their local machine, work on the code and push the code (they share the changes to Github – with the other team members). If it’s the case, the automatic CI/CD pipeline defined by Github workflows take care of it and redeploys the application.\nTo run and test the application locally, you need:\n\nlocal application running with the client\nlocal application running wiht the backend (server)\n\n\nDevelopment flow\n\nclone application locally\ninstall needed dependencies to run it locally\nimplement a new feature / fix a bug\ntest locally that everything works correctly\npush the new code the remote (Github) usually on a feature branch\nonce the code is tested and ready to be integrated into production, the feature branch gets merged into the main branch, triggering the deployment"
  },
  {
    "objectID": "index.html#what-do-you-need-before-starting",
    "href": "index.html#what-do-you-need-before-starting",
    "title": "Tutorial 1 - SOPRA",
    "section": "2 What do you need before starting",
    "text": "2 What do you need before starting\nTo clone the code on your machine and run it locally, you need to set-up / have installed:\n\ngit: version control system\njava 17+ (JDK) installed and JAVA_HOME environment variable set\nGithub account\nssh key to authenticate with Github easily\n\nYou will install other needed packages from set-up files provided by the repositories.\n\n\n\n\n\n\nWarning\n\n\n\nIf you are on Windows, make sure to install WSL (Windows Subsystem for Linux) first.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf your are on a Mac, I highly recommend installing Homebrew as package manager:\n\nYou can install packages with: brew install &lt;package_name&gt;\nYou can install applications with: brew install --cask &lt;application_name&gt;\n\n\n\n\n\n\n\n\n\nNoteSetup ssh key\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you are on Windows, first install Linux Subsystem for Windows (WSL) and then follow the instructions below.\n\n\nIn your terminal:\nssh-keygen -t ed25519 -C \"&lt;my_computer_name&gt;\"\nIt will prompt you for:\n\nchoosing location (default is fine)\nchoosing a passphrase (optional: can leave blank for no passphrase)\n\nThen, add the ssh key to the ssh-agent:\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_ed25519\nYou need the public key to add it to your Github account:\ncat ~/.ssh/id_ed25519.pub\n\n\n\n\n\n\nNoteLink ssh key to Github account\n\n\n\n\n\n\nGo to your Github settings\n\n\n\nGo to “SSH and GPG keys”\n\n\n\nClick on “New SSH key”, give it a title (e.g. “My Laptop”) and paste the public key you got from cat ~/.ssh/id_ed25519.pub\n\n\n\nOnce you added it, you can use ssh to clone repositories from Github:\n\n\n\n\n\nNow you are able to act on remote repositories hosted on Github without entering your credentials every time. Always use the ssh url when cloning repositories from Github.\n\n\n\n\n\n\n\n\n\nNoteInstall Java 17\n\n\n\n\n\n\n\n\n\n\n\nNoteMac\n\n\n\n\n\nIf you are on a Mac, you can install Java 17 with Homebrew:\nbrew install --cask temurin@17\nRun:\n/usr/libexec/java_home -v 17\n/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home\nto locate your Java 17 installation path.\nRun:\nwhich ${SHELL}\n/bin/zsh\nto find out which shell you are using.\nThen, add the following line to your shell configuration file (.zshrc for zsh, .bash_profile or .bashrc for bash):\ncode ~/.zshrc\npaste\nexport JAVA_HOME=$(/usr/libexec/java_home -v 17)\nexport PATH=\"$JAVA_HOME/bin:$PATH\"\nat the end of the file, save and close it.\nRun source ~/.zshrc to reload the configuration file.\n\n\n\n\n\n\n\n\n\nNoteLinux / WSL\n\n\n\n\n\nAfter making sure you have git and curl installed on your system:\nsudo apt update\nsudo apt install git curl\nyou can install Java 17 with:\nsudo apt install openjdk-17-jdk\nDepending on your package manager of choice.\n\n\n\nEnsure you have Java 17 installed and configured correctly by running:\nmacvm@Macs-Virtual-Machine sopra_server_tutorial % java -version\nopenjdk version \"17.0.17\" 2025-10-21\nOpenJDK Runtime Environment Temurin-17.0.17+10 (build 17.0.17+10)\nOpenJDK 64-Bit Server VM Temurin-17.0.17+10 (build 17.0.17+10, mixed mode, sharing)\n\n\n\n\n\n\n\n\n\nNoteInstall WSL on Windows\n\n\n\n\n\nIf you are using Windows, you need to install WSL (Windows Subsystem for Linux) before continuing with the Linux/WSL installation steps (Git, Curl, Java, …).\n\n\n\n\n\n\nTip\n\n\n\nSave your work first: the installation may require a reboot.\n\n\n\nOpen PowerShell as Administrator Start Menu → search PowerShell → right-click → Run as administrator\nRun:\n\nwsl --install"
  },
  {
    "objectID": "index.html#clone-repositories-run-code-locally",
    "href": "index.html#clone-repositories-run-code-locally",
    "title": "Tutorial 1 - SOPRA",
    "section": "3 Clone repositories & run code locally",
    "text": "3 Clone repositories & run code locally\nNavigate to the folder where you want to store the project and clone the repository:\ncd &lt;path_to_your_folder&gt;\ngit clone git@github.com:&lt;user_name&gt;/&lt;repository_name&gt;.git\nwhere &lt;repository_name&gt; are the names of the server and client repositories you created from sopra templates.\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\nmacvm@Macs-Virtual-Machine ~ % mkdir sopra\nmacvm@Macs-Virtual-Machine ~ % cd sopra\nmacvm@Macs-Virtual-Machine sopra % git clone git@github.com:&lt;user_name&gt;/sopra_server_tutorial.git\nCloning into 'sopra_server_tutorial'...\nThe authenticity of host 'github.com (140.82.121.4)' can't be established.\nED25519 key fingerprint is &lt;your_SHA256_fingerprint&gt;.\nThis key is not known by any other names.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added 'github.com' (ED25519) to the list of known hosts.\nremote: Enumerating objects: 73, done.\nremote: Counting objects: 100% (73/73), done.\nremote: Compressing objects: 100% (46/46), done.\nremote: Total 73 (delta 3), reused 72 (delta 3), pack-reused 0 (from 0)\nReceiving objects: 100% (73/73), 71.61 KiB | 596.00 KiB/s, done.\nResolving deltas: 100% (3/3), done.\nmacvm@Macs-Virtual-Machine sopra % git clone git@github.com:&lt;user_name&gt;/sopra_client_tutorial.git\nCloning into 'sopra_client_tutorial'...\nremote: Enumerating objects: 52, done.\nremote: Counting objects: 100% (52/52), done.\nremote: Compressing objects: 100% (47/47), done.\nremote: Total 52 (delta 0), reused 52 (delta 0), pack-reused 0 (from 0)\nReceiving objects: 100% (52/52), 120.59 KiB | 620.00 KiB/s, done.\nmacvm@Macs-Virtual-Machine sopra % ls\nsopra_client_tutorial   sopra_server_tutorial\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nUse the ssh url when cloning the repository.\n\n\nAt this point you can already look into the code, read the README.md file and run the project locally.\n\n\n\n\n\n\nTip\n\n\n\nIf you are using VSCode as code editor, you can open the folder directly from terminal with code &lt;repo_name&gt; after activating Shell Command: Install 'code' command in PATH from the Command Palette (Cmd+Shift+P / Ctrl+Shift+P).\nOr code . to open the current folder.\n\n\n\n3.1 Client repository\n\n\n\n\n\n\nTip\n\n\n\nIf while cd-ing into a repo folder this message shows up:\nmacvm@Macs-Virtual-Machine sopra % cd sopra_server_tutorial\ndirenv: error /Users/macvm/sopra/sopra_server_tutorial/.envrc is blocked. Run `direnv allow` to approve its content\nrun direnv allow to enable the automatic environment variable loading. If direnv is not installed, install it with your package manager of choice (or curl it).\n\n\nRun source setup.sh as described in the README.md to install needed packages / dependencies.\nDeno and npm (2 TS to JS runtimes) are available in the repository: use npm run dev to run the development server locally (at default port localhost:3000).\nAt package.json you can find available scripts:\n\"scripts\": {\n    \"dev\": \"next dev --turbopack\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"deno lint\",\n    \"fmt\": \"deno fmt\"\n  },\nThe code for your app lives under app/ folder: there you can find the entry point to the application at app/page.tsx. Try to change something to see it automatically update in the browser on save.\n\n\n3.2 Server repository\nTo build the application, use the provided Gradle wrapper. You first need to grant permission to the executable:\nchmod +x gradlew\n./gradlew build\nThe first time you run this, the Gradle wrapper will download the necessary Gradle distribution.\nIf everything works correctly, you will see:\nBUILD SUCCESSFUL in 2m 50s\n7 actionable tasks: 7 executed\n\n\n\n\n\n\nNote\n\n\n\nAs suggested in the README.md, you can build the application continuously with:\n./gradlew build --continuous -xtest\nthe two flags allow for:\n\n--continuous: to automatically recompile the code on changes\n-xtest: to skip running tests on every build\n\n\n\nTo run the server locally, use:\n./gradlew bootRun\nThis runs on localhost:8080 by default: there you will see The application is running.\nAt localhost:8080/h2-console you can access the H2 database console: Information needed to access the console are at src/main/resources/application.properties."
  },
  {
    "objectID": "index.html#git-github-workflows",
    "href": "index.html#git-github-workflows",
    "title": "Tutorial 1 - SOPRA",
    "section": "4 Git & Github workflows",
    "text": "4 Git & Github workflows\n\n4.1 Git short guide\nTo get started working with local / remote repositories and collaborate with your team members, it’s important to get to know the most used git commands. Videos, the official documentation and LLMs (with caution) are a good starting point.\nHere we selected a subset of commands we consider relevant for this course.\n\n\n\n\n\n\nNoteFundamentals\n\n\n\n\n\nGit is a version control system based on branches that allows users to keep track of the file changes at a location. It allows to store incremental changes (commits) and to develop experimental features separately to the main code (branch and merge). ALl of this happens locally, on your machine. It’s possible to connect your local repository to a remote origin (this happens automatically when you clone a repository from Github). Github simply acts as a second peer (the upstream) to whom you can push changes and from which you can pull changes (added by a team member).\nThe repositories you work on for Milestone 1 only have 1 branch, the main branch (standard entry point for an application).\n\ngit pull tries to copy the changes of the branch you are currently on from the remote repository to your local one. This allows you to stay up-to-date with changes from other users.\n\nLet’s say you modified a file in your repository:\n\n\n\nadd title to main page.tsx\n\n\n\n\n\n\n\n\ngit status is a very useful command that gives you the snapshot (current state) of your branch:\n\ntells you on what branch you are and wheter it’s up-to-date with the remote branch\nlists all the files that were: modified, added, removed\nlists all the changes that are: untracked, unstaged, staged\n\nYou can move a change to the staging area (prepare them for a commit) with:\n\ngit add &lt;file_name&gt;\ngit add . to add all changes at once\n\nRun git  status to see what happened\n\n\n\n\n\n\nCaution\n\n\n\nBefore commiting the first time, ensure your user.name and user.email are properly set. In this way you can sign the commit: use your Github email and username to do so with:\nmacvm@Macs-Virtual-Machine sopra_client_tutorial % git config --local user.name \"&lt;username&gt;\"\nmacvm@Macs-Virtual-Machine sopra_client_tutorial % git config --local user.email \"&lt;email&gt;\"\nmacvm@Macs-Virtual-Machine sopra_client_tutorial % git config --local user.name\n&lt;username&gt;\nmacvm@Macs-Virtual-Machine sopra_client_tutorial % git config --local user.email\n&lt;email&gt;\nmacvm@Macs-Virtual-Machine sopra_client_tutorial %\nYou can choose beetween:\n\nthe --local flag (recommended) that sets name and email for this specific repository (you need to do it both on the server and on the client repositories). This allows you to have multiple repositories on your computer linked to remotes where you are logged with different accounts / you want to sign your commits differently\nthe --global flag: all the commits on your machine are going to be signed with name and email you set\n\n\n\nWith commit -m \"&lt;commit_message&gt;\" you can create a commit with its commit message (where you described the changes / reference the issue / bug it solves)\nYou can see your commit with git log.\nYou can push the commit(s) to the remote repository with:\n\ngit push if the branch already exist on the remote\ngit push --set-upstream origin &lt;new_branch_name&gt; to register a new local branch with your commit(s) on the remote repository\n\n\n\n\n\n\n\n\n\n\nNoteBranching\n\n\n\n\n\nA branch is a reference (pointer) to a commit, usually used to develop a new feature, fix a bug, etc. while maintaining the main branch (often – and in this course – continously deployed) always working.\nAccess branches\n\nYou can move your HEAD to an already existing branch with git checkout &lt;branch_name&gt;\nYou can create a new branch pointing at current HEAD location with git checkout -b &lt;new_branch_name&gt;\n\nYou can fetch updates of a branch / branches in a repository with:\n\ngit fetch &lt;branch-name&gt; gets you updates of that branch\ngit fetch --all tells you what’s new: new branch(es) has been created\ngit branch lists all locally available branches (often useful to run together with git fetch --all)\n\nManage branches\nOnce your work in a branch is finished and you are ready to integrate your changes to the main branch (to deploy it). You want to merge your branch on the main branch:\n\nmove to main: git checkout main\nmerge your_branch to main: git merge &lt;your_branch&gt;\nthis will create new commits on top of the main branch. Your branch and commits still exists at git checkout &lt;your_branch&gt;\nto update the remote repository with your changes: git push\n\n\n\n\n\n\n\nCaution\n\n\n\nbefore merging, always pull to get the latest changes on main\n\n\nIf you are interested in other ways to manage your branches and history, look into rebase and cherrypick.\nDelete a branch\n\nYou can delete a branch locally with git branch -d &lt;branch_name&gt;\nYou can publish your deletion (delete the branch on the remote repository as well) with git push origin --delete &lt;branch_name&gt;\n\n\n\n\n\n\n\n\n\n\nWarningRecovery\n\n\n\n\n\nIf while working you realize you commited / pushed / lost something accidentally git offers some commands to rescue your code.\nReshape local history\nIf you didn’t yet pushed your changes / commit to the remote repository, you are free to modify them as you wish:\n\ngit reset --soft HEAD~1 removes your last commit and leaves your changes in the staging area. This is useful if you want to add / remove something from that commit or change the commit message. (Be careful: make sure to use the --soft flag)\ngit rebase -i &lt;commit_hash&gt; lets you modify interactively the commits from your HEAD to the commit the hash references to. This is useful to squash commits together, modify their commit messages or drop them.\n\n\nWhen needed (eg. when rebasing), git opens an interactive shell. By default is vi. If you wish to change it, you can configure the behavior with:\ngit config --global core.editor \"code --wait\"\n\n--global or --local flags to change the editor everywhere or just for this repository\nthe --wait flag is needed for window-based editors: it waits until you close the editor to proceed. This is not needed with terminal-based editors.\n\n\nRecover a lost commit / branch\nA useful command in this scenario is git reflog. It shows all the recent places (hashes) you HEAD has been pointing to: you can checkout to the desired hash, branch off and recover that snapshot.\nReshape remote (shared) history\nAs a general advice, you should never change the history of an already pushed commit / branch. This can cause a lot of troubles to your team members and prevent you to recover specific changes or have a good sense of the rationale behind a change.\nIn an ideal world, each commit has the right size: not too small, not too big – contains one specific change described by a clear commit message that explains what the commit does and references the issue / bug it implements / solve. Unfortunately we don’t live in an ideal world and sometimes the history of a repository is not as clean as we wish.\nIf you want a clean history on the main branch / on specific feature branches, it’s advised to:\n\nrebase the feature branch before merging on the main branch: many changes appear as a single commit and the remote branch stays untouched (preserving the full history)\ncreate a new cleaned branch to keep working on / to merge, but keeping the old branch for future reference / recovery.\n\nYou should decide as a team what you want to prioritise and what approach / rules to follow in this project.\n\n\n\n\n\n\n\n\n\nWarningResolve conflicts\n\n\n\n\n\nWhen collaborating on a git repository, more developers may modify the same file / functionality. This divergence creates conflict:\n\ngit asks itself: what should I keep between the 2 options I see?\n\nIn most cases, git solves this conflicts automatically:\n\neg. when pulling, if you set git config pull.rebase true, git tries automatically to move your changes on top of the pulled commits).\nwhen changes are on same file / functionality but not conflicting: can keep both of them\n\ngit will prompt you to resolve conflicts only when it wasn’t able on its own to decide what to keep and what to ignore. This often happens when you merge a feature branch into your main branch. Most code editors (VS code eg.) have built-in conflicts resolution tools we suggest to use.\n\n\n\n\n\n\nNoteDemonstration\n\n\n\n\n\n\n\n\n\n\n\nMerge without conflicts\n\n\n\n\nWe want to modify how users/[id] looks\n\n\n\n\n\nFor this let’s create a branch to work on: #101_restyle_user\n\n\n\n\n\nThere we modify the code and get:\n\n\n\n\n\n2 new files and 1 modified - we can commit and push (on #101_restyle_user)\n\n\n\n\n\nwhen we checkout to main and merge everything works: git was able to resolve conflicts on its own\n\n\n\n\n\nThe new commit is added to the history of main\n\n\n\n\n\n\n\n\n\n\n\n\nMerge with conflicts\n\n\n\n\nLet’s modify the userHeader() function on #101_restyle_user\n\n\n\n\n\nCommit and push (on #101_restyle_user)\n\n\n\n\n\nLet’s modify the same function userHeader() on main in a different way - commit\n\n\n\n\n\nTry to merge #101_restyle_user on main → conflict\n\n\n\n\n\nIn VS code (under the git tab) you can see merge conflicts - click on Resolve in Merge Editor\n\n\n\n\n\nHere you can choose what to keep and what to discard (or manually update the file to a new resolution) - click Complete Merge when you are done (0 conflicts)\n\n\n\n\n\nYou can click continue to proceed with the merge with conflicts resolved\n\n\n\n\n\nYou can see the updated graph after merging and resolving conflicts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipBest practices\n\n\n\n\n\nCommits\n\nkeep your commits small / reasonable size: each commit should implement and be responsible of a specific change (add a feature, solve a bug)\ngive a title (short description) to your commit messages, then explain what you did and why. If possible, reference to an issue / bug number the commit is about.\n\nBranches\n\nname your branches in a clear way: decide with your team what is the criteria for naming branches:\n\ncamelCase, snake_case, etc.\njust issue number / issue number + name\nnaming convention when a feature branch is checked out\n\n\nGeneral\n\nalways pull before you start working (fetch as well)\nalways pull before you push\n\n\n\n\n\n\n4.2 Github workflows\nThe SOPRA project relies on CI/CD (Continuous Integration / Continuous Deployment) to deploy (publish) the changes from the repositories hosted on Github to:\n\nVercel for the client\nGoogle Cloud for the server\n\nInstead of manually testing and deploying your code, Workflows are defined using GitHub Actions. These workflows are defined in YAML files located in .github/workflows/ inside your repository. They define when they should run and allow granular and automated control on the deployment.\n\n\n\n\n\n\nNoteEnvironment Variables & Secrets\n\n\n\n\n\nApplications require configuration that changes depending on where the code is running (e.g., a database URL that is localhost on your laptop but a Google Cloud URL in production) or sensitive data (passwords, API keys).\nLocally (.env): On your machine, you store these in a .env file. The repository already includes a .gitignore that prevents this file from being uploaded to GitHub.\n\n\n\n\n\n\nWarningSecurity Risk\n\n\n\nNever commit your .env file or hardcode API keys/passwords in your source code. If you push a key to a public repository, it is compromised immediately.\n\n\nRemotely (GitHub Secrets): To let GitHub Actions access these values (to login to Google Cloud or Vercel), you must store them in the repository settings under Settings &gt; Secrets and variables &gt; Actions.\n\n\n\n\n\n\n\n\n\nNoteWorkflow example (client)\n\n\n\n\n\nWorkflow files are usually intuitive enough to read and unsderstand. If we take the client deployment to Vercel as an example (.github/workflows/verceldeployment.yml):\nname: Deploy to Vercel\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repo\n        uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"18\"\n\n      - name: Install Dependencies\n        run: npm install\n\n      - name: Deploy to Vercel\n        run: npx vercel --prod --token ${{ secrets.VERCEL_TOKEN }} --confirm\n        env:\n          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}\n          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}\nWhen new code is pushed to the main branch, 1 jobs is runned:\n\ndefines the type of job (deploy) and the environment (latest Ubuntu)\ndefined the steps: first it install needed resources\nthen – in this case – reaches out to Vercel to deploy the frontend application\nto do so it needs environmnet variables (secrets) to connect and authenticate to Vercel. This secrets are defined in the repository settings.\n\n\n\n\nWhen deploying you need to make sure that the Environment variables are set correctly in the repository settings in Github. You can add / modify the content of these files to control their behavior. eg. you might want to deploy a staging environment (develop branch) and test your changes in a production-like environment without making them accessible in production (main)."
  },
  {
    "objectID": "index.html#set-up-google-cloud-and-vercel-deploy-your-project",
    "href": "index.html#set-up-google-cloud-and-vercel-deploy-your-project",
    "title": "Tutorial 1 - SOPRA",
    "section": "5 Set-up Google Cloud and Vercel & deploy your project",
    "text": "5 Set-up Google Cloud and Vercel & deploy your project\nTo make the application available, you need to deploy your changes:\nServer repository\nmain.yml file runs 2 jobs when pushed on main:\n\ntest (optional for now): runs the Jtest on the packaged version and make the results available at SonarQube\ndeploy: deploys the application to the Google Cloud instance set-up as described below.\n\ndockerize.yml creates a docker container and register it. This is optional for now, but will be needed later: a dedicated section explains what docker is and how to set it up.\nClient repository\nverceldeployment.yml file deploys the frontend code to vercel when pushed on main\ndockerize.yml does exactly the same, but for the client (optional for now).\nsonarcloud.yml runs an analysis (scan) of the code and publish the resulsts to SonarQube (optional for now)\n\n5.1 Set-up Google Cloud and link it to the server repository\nTo set up the backend infrastructure on Google Cloud, the following services and entities must be successfully configured and enabled (as illustrated in the step-by-step tutorials):\nCore Infrastructure\n\nGCP Project: A dedicated project container named sopra-fs26-[lastname]-[firstname]-server.\nApp Engine Application: The specific environment where the Java/Spring Boot server resides, localized in the europe-west6 region.\n\nIdentity & Access Management (IAM)\n\nService Account: A virtual identity used by GitHub Actions to interact with your Google Cloud resources.\nEditor Role: The specific permission level granted to the Service Account to allow resource modification.\nService Account Key: A generated JSON key that serves as the “password” for GitHub to log into your Google Cloud project.\n\nCloud APIs (Must be “Enabled”)\n\nCloud Build API: Handles the building of your application code into a deployable format.\nApp Engine Admin API: Allows external tools (like GitHub Actions) to manage and deploy versions of your App Engine service.\n\nSecrets Management\n\nGCP_SERVICE_CREDENTIALS: The GitHub Actions secret containing the JSON key, which bridges the link between your code repository and the Google Cloud entities listed above.\n\n\n\n\n\n\n\nNoteSet-up Google Cloud\n\n\n\n\n\n\n\n\nNavigate to cloud.google.com and create an account / login\n\n\n\n\nClick on console\n\n\n\n\n\nClick on the project selection\n\n\n\n\n\nCreate new project\n\n\n\n\n\nName it according to specification: sopra-fs26-lastname-firstname-server & click create\n\n\n\n\n\nNavigate to IAM and admin &lt; Service accounts\n\n\n\n\n\nCreate a new service account\n\n\n\n\n\nName it as you wish (it will grant editor access) & click Create and continue\n\n\n\n\n\nadd editor role in step 2 - permission (you can search for it) & click Continue\n\n\n\n\n\nClick done\n\n\n\n\n\nNext to the created service account, select more &gt; Manage keys\n\n\n\n\n\nAdd a new key\n\n\n\n\n\nin JSON format (default)\n\n\n\n\n\nKey creation confirmation screen - the key as JSON file is saved on your computer\n\n\n\n\n\nUse top bar to search for App Engine\n\n\n\n\n\nCreate new application\n\n\n\n\n\nchoose time zone europe-west6 and connect the editor service account created before\n\n\n\n\n\nConfirmation screen\n\n\n\n\n\nUse the top bar to search for APIs and services\n\n\n\n\n\nClick + Enable APIs and services\n\n\n\n\n\nSearch for Cloud Build API\n\n\n\n\n\nClick on Cloud Build API\n\n\n\n\n\nEnable it\n\n\n\n\n\nConfirmation screen: Cloud Build API is active\n\n\n\n\n\nBack to the API library, search for App Engine Admin API\n\n\n\n\n\nClick on App Engine Admin API\n\n\n\n\n\nEnable it\n\n\n\n\n\nConfirmation screen: App Engine Admin API is active\n\n\n\n\n\nGo to the server repository on Github & go to the Settings\n\n\n\n\n\nLook for Secrets and variables &gt; Actions\n\n\n\n\n\nAss a New repository secret\n\n\n\n\n\nName it GCP_SERVICE_CREDENTIALS and paste as value the content of the JSON file you download before from Google Cloud console\n\n\n\n\n\nBack to Google Cloud console - search for App Engine\n\n\n\n\n\nHere you find the link where your backend (server) will be deployed - copy it\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePush to deploy & verify changes\n\n\n\n\n\nGoogle Cloud console is now setup and the secrets are loaded in Github: the next time you push to the remote repository, the server application will be automatically deployed (based on the .gtihub/workflows).\nWe can test this out by making some changes locally:\n\n\n\n\n\n\nLocal changes: add GET /users/{id} endpoint\n\n\n\n\nnew endpoint in users.controller (I have also modified the correpsonding DTO and service files)\n\n\n\n\n\nAfter creating 3 users, I can see the database locally\n\n\n\n\n\nTest locally my new endpoint\n\n\n\n\n\nCommit and push the changes\n\n\n\n\n\nWe are interested in this deploy workflow\n\n\n\n\n\nConfirmation: the Deploy to App Engine workflow succeded - for now ignore the other 2\n\n\n\n\n\nNow we can test the new endpoint in production (prod_url is the link we copied before from App Engine)  I create 2 users (here you see how to POST a new user)\n\n\n\n\n\nfrom prod_url/h2-console, you can see the tables as you did locally (to access use the same authentication)\n\n\n\n\n\nTest the new endpoint in production\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteUpdate fallback prodUrl in the client repository\n\n\n\n\n\n\n\n\n\n\n\nMake sure to have the server production URL copied to the clipboard (you find it at Google Cloud console &gt; App Engine)\n\n\n\n\nOpen the client repository in an IDE of your choice\n\n\n\n\n\nLook for app/utils/domain.ts and replace the hardcoded fallback value to the URL you just copied - you completed the TODO commented out there\n\n\n\n\n\n\nIdeally the server URL in production comes from NEXT_PUBLIC_PROD_URL that we are going to set-up later (in the dedicated Vercel part of this tutorial). This only serves as a fallback if, for some reason, the environment variable set in vercel is not retrieved correctly.\n\n\n\n\n\n\n\n\n\nNoteSet-up Sonar cloud and connect it to the sever repository (optional)\n\n\n\n\n\n\n\n\nGo to https://www.sonarsource.com/\n\n\n\n\nRegister or login (best if with your Github account)\n\n\n\n\n\nClick Analyze new project\n\n\n\n\n\nChoose your organization and link the server repository\n\n\n\n\n\nLeave default Previous version toggle & click Create project\n\n\n\n\n\nUnder Administration &gt; Analysis Method turn off the toggle Automatic Analysis (since we are going to push it via CI)\n\n\n\n\n\nModify your build.gradle as in the diff (server repository)\n\n\n\n\n\nModify your main.yml worflow file as in the diff (server repository)\n\n\n\n\n\nWe now need to collect the secrets to connect the server repo to sonarcloud. You find the Project Key and Organization Key under Information - copy them\n\n\n\n\n\nAdd a new secret to the server repository: SONAR_PROJECT_KEY (Project Key)\n\n\n\n\n\nAdd new secret: SONAR_ORGANIZAZION (Organization Key)\n\n\n\n\n\nTo get the token, click on your profile picture &gt; My Account &gt; Security - enter a token name (whatever you prefer) &gt; click Generate Token\n\n\n\n\n\nCopy the generated token\n\n\n\n\n\nAdd new secret: SONAR_TOKEN\n\n\n\n\n\nAt this point you should have added 3 new secrets to your server repository\n\n\n\n\n\nCommit and push the changes to your server repository. Now both the Google cloud deploy and the Test and Sonarqube should be successfull\n\n\n\n\n\nIn SonarQube, under your project, you can see the results\n\n\n\n\n\nand navigate between them\n\n\n\n\n\n\n\n\n\n\n\n5.2 Set-up Vercel and link it to the client repository\nTo set up the frontend on Vercel, the following components must be configured (as in the step-by-step tutorial):\nPlatform & Project\n\nVercel Project: Linked directly to your GitHub client repository.\nDeployment URL: The live production link for the web application.\n\nGitHub Secrets (for CI/CD)\n\nVERCEL_TOKEN: Authorized access token for deployment.\nVERCEL_ORG_ID: Your Vercel account/organization identifier.\nVERCEL_PROJECT_ID: The specific ID for the client project.\n\nEnvironment Variables\n\nNEXT_PUBLIC_PROD_URL: The backend’s Google Cloud URL, stored in Vercel settings to enable frontend-backend communication.\n\n\n\n\n\n\n\nNoteSet-up Vercel project and connect the client repository\n\n\n\n\n\n\n\n\nNavigate to vercel.com\n\n\n\n\nCreate an account or login (best if with your Github account)\n\n\n\n\n\nCreate a new project\n\n\n\n\n\nConnect the client repository (either you already connected your Github profile or you should do it now)\n\n\n\n\n\nName the project & click Deploy\n\n\n\n\n\nThe deployment will start\n\n\n\n\n\nConfirmation: deployment was succesfull\n\n\n\n\n\nThis is the overview page of your Vercel project\n\n\n\n\n\nIn the .github/workflows/verceldeployment.yml you can see that 3 secrets are needed: this should be added to the github client repository\n\n\n\n\n\nIn Vercel under Settings &gt; General, you will find your Project ID - copy it\n\n\n\n\n\nIn your client repository, create an new repository secret matching precisely the name from your workflow file: VERCEL_PROJECT_ID\n\n\n\n\n\nTo find your User ID (= Organization ID), navigate to the Account Settings\n\n\n\n\n\nUnder General, you find the User ID - copy it\n\n\n\n\n\nNew repository secret VERCEL_ORG_ID - paste the copied User ID (= Organization ID)\n\n\n\n\n\nTo generate a new Token, from the Account Settings &gt; Tokens - give it a name (whatever you want), a scope (your organization) and an expiration date - click create\n\n\n\n\n\nConfirmation: token is created - copy it\n\n\n\n\n\nNew repository secret: VERCEL_TOKEN - paste the copied token\n\n\n\n\n\nThe 3 secrets should be visible under Settings &gt; Secrets and variables in your client repository\n\n\n\n\n\nWe need to add a last Environment Variables in Vercel &gt; your client project &gt; Settings &gt; Environment Variables &gt; Add Environment Variable\n\n\n\n\n\nName NEXT_PUBLIC_PROD_URL and paste the server production URL from Google Cloud console &gt; App Engine (the same we pasted into the client repository in domain.ts)\n\n\n\n\n\nNow you can commit and push your changes from the client repository\n\n\n\n\n\nThe Vercel deployment workflow will start\n\n\n\n\n\nFrom the overview page of your project, you can Visit the deployed client side application\n\n\n\n\n\nVerify it’s connected with the backend (server repository deployed on Google Cloud) by navigating to /users - here we see the users we created before\n\n\n\n\n\nunder /login you can create a new user\n\n\n\n\n\nand verify it has been created\n\n\n\n\n\n\n\n\n\n\n\n5.3 Set-up Docker Hub and containerize your server application\nDocker allows you to package your application into a container – a standardized unit that includes everything needed to run the software (code, runtime, libraries, dependencies). This makes it easy to run your application consistently on any machine.\n\n\n\n\n\n\nNoteCreate Docker Account\n\n\n\n\n\n\nNavigate to hub.docker.com and create an account\nIncorporate your group number into the account name, for example sopra_group_12\nAfter logging in, click Create repository\nName the repository exactly the same as your GitHub server repository name (e.g., sopra-fs26-template-server) – set visibility to Public & click Create\n\n\n\n\n\n\n\n\n\n\nNoteAdding Secrets\n\n\n\n\n\n\nFrom Docker Hub, click on your profile picture &gt; Account settings &gt; Personal access tokens\nClick Generate new token – give it a description (e.g., github-actions), select Read & Write access & click Generate\nCopy the generated token immediately – you won’t be able to see it again\nGo to your server repository on GitHub &gt; Settings &gt; Secrets and variables &gt; Actions\nClick New repository secret and add the following 3 secrets:\n\n\n\n\n\n\n\n\nName\nValue\n\n\n\n\ndockerhub_username\nYour Docker Hub username (e.g., sopra_group_12)\n\n\ndockerhub_password\nThe PAT you generated (not your login password!)\n\n\ndockerhub_repo_name\nYour Docker Hub repository name\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThe secret names must match exactly what’s in your workflow file, including lowercase letters and underscores.\n\n\n\n\n\n\n\n\n\n\n\nNoteRunning Workflow\n\n\n\n\n\nPush any change to your main branch to trigger the workflow:\nbash git add . git commit -m “trigger docker build” git push origin main\nGo to your GitHub repository &gt; Actions tab – you should see the Dockerize workflow running. Once successful (green checkmark), go to your Docker Hub repository – you should see your image with the latest tag."
  }
]